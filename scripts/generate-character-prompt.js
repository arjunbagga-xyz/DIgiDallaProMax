#!/usr/bin/env node

/**
 * Character Prompt Generation Script
 * Uses Gemini AI to generate contextual prompts for characters
 */

const fs = require("fs").promises
const path = require("path")
const fetch = require("node-fetch")

// Character configurations
const CHARACTERS = {
  emma: {
    id: "emma",
    name: "Emma",
    backstory: "Travel blogger exploring hidden gems around the world",
    personality: ["adventurous", "curious", "authentic", "mindful", "optimistic"],
    isActive: true,
  },
  maya: {
    id: "maya",
    name: "Maya",
    backstory: "Digital artist and creative mentor inspiring others",
    personality: ["creative", "inspiring", "thoughtful", "passionate", "supportive"],
    isActive: true,
  },
  alex: {
    id: "alex",
    name: "Alex",
    backstory: "Urban photographer and coffee enthusiast",
    personality: ["observant", "contemplative", "urban", "artistic", "social"],
    isActive: true,
  },
}

// Configuration
const CONFIG = {
  geminiApiKey: process.env.GEMINI_API_KEY,
  characterId: process.env.CHARACTER_ID || process.argv[2],
  style: process.env.STYLE || "artistic",
  mood: process.env.MOOD || "dynamic",
  count: Number.parseInt(process.env.COUNT) || 1,
  saveToFile: process.env.SAVE_TO_FILE !== "false",
}

// Logging utility
const logger = {
  info: (msg) => console.log(`[INFO] ${new Date().toISOString()} - ${msg}`),
  warn: (msg) => console.warn(`[WARN] ${new Date().toISOString()} - ${msg}`),
  error: (msg) => console.error(`[ERROR] ${new Date().toISOString()} - ${msg}`),
}

async function loadCharacters() {
  try {
    const charactersPath = path.join(process.cwd(), "data", "characters.json")
    const data = await fs.readFile(charactersPath, "utf-8")
    return JSON.parse(data)
  } catch (error) {
    logger.error(`Failed to load characters: ${error.message}`)
    return []
  }
}

async function loadPromptHistory(characterId) {
  try {
    const promptsPath = path.join(process.cwd(), "data", "generated-prompts.json")
    const data = await fs.readFile(promptsPath, "utf-8")
    const prompts = JSON.parse(data)
    return prompts.filter((p) => p.characterId === characterId)
  } catch (error) {
    return []
  }
}

async function generatePromptWithGemini(character, context) {
  if (!CONFIG.geminiApiKey) {
    throw new Error("GEMINI_API_KEY environment variable is required")
  }

  const systemPrompt = `You are an expert AI art prompt generator. Create detailed, creative prompts for image generation that capture the essence of the character while being visually compelling.

Character Details:
- Name: ${character.name}
- Personality: ${character.personality}
- Backstory: ${character.backstory}

Style Preferences: ${context.style}
Mood: ${context.mood}
Previous Prompts: ${context.recentPrompts.slice(0, 3).join("; ")}

Guidelines:
1. Create a unique prompt that hasn't been used recently
2. Include the character's name and key personality traits
3. Incorporate visual elements that match the requested style and mood
4. Keep prompts between 50-150 words
5. Focus on visual details, lighting, composition, and atmosphere
6. Avoid repetitive elements from recent prompts

Generate a single, detailed prompt for image generation.`

  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${CONFIG.geminiApiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [
            {
              parts: [{ text: systemPrompt }],
            },
          ],
          generationConfig: {
            temperature: 0.8,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 200,
          },
        }),
      },
    )

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error?.message || "Gemini API request failed")
    }

    const result = await response.json()
    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text

    if (!generatedText) {
      throw new Error("No text generated by Gemini")
    }

    return generatedText.trim()
  } catch (error) {
    logger.error(`Gemini API error: ${error.message}`)
    throw error
  }
}

async function generateInstagramCaption(prompt, character) {
  const captionPrompt = `Create an engaging Instagram caption for this AI-generated image:

Character: ${character.name}
Image Prompt: ${prompt}

Requirements:
1. Keep it under 150 characters
2. Include relevant hashtags
3. Maintain the character's personality
4. Make it engaging and shareable

Generate only the caption text.`

  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${CONFIG.geminiApiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [
            {
              parts: [{ text: captionPrompt }],
            },
          ],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 100,
          },
        }),
      },
    )

    if (!response.ok) {
      throw new Error("Failed to generate caption")
    }

    const result = await response.json()
    return result.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || ""
  } catch (error) {
    logger.warn(`Caption generation failed: ${error.message}`)
    return `${prompt} ✨\n\n#AIArt #GeneratedContent #DigitalArt`
  }
}

async function savePrompt(characterId, prompt, caption) {
  if (!CONFIG.saveToFile) return

  try {
    const promptsPath = path.join(process.cwd(), "data", "generated-prompts.json")

    let prompts = []
    try {
      const data = await fs.readFile(promptsPath, "utf-8")
      prompts = JSON.parse(data)
    } catch (error) {
      // File doesn't exist, start with empty array
    }

    const newPrompt = {
      id: `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      characterId,
      prompt,
      caption,
      createdAt: new Date().toISOString(),
      used: false,
      imageGenerated: false,
      posted: false,
    }

    prompts.push(newPrompt)

    // Keep only the last 100 prompts per character
    const characterPrompts = prompts.filter((p) => p.characterId === characterId)
    if (characterPrompts.length > 100) {
      const toRemove = characterPrompts.slice(0, characterPrompts.length - 100)
      prompts = prompts.filter((p) => !toRemove.includes(p))
    }

    await fs.writeFile(promptsPath, JSON.stringify(prompts, null, 2))
    logger.info(`Prompt saved: ${newPrompt.id}`)

    return newPrompt
  } catch (error) {
    logger.warn(`Failed to save prompt: ${error.message}`)
  }
}

async function generatePromptsForCharacter(character, count = 1) {
  logger.info(`Generating ${count} prompt(s) for ${character.name}`)

  // Load recent prompts to avoid repetition
  const recentPrompts = await loadPromptHistory(character.id)
  const recentPromptTexts = recentPrompts
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
    .slice(0, 10)
    .map((p) => p.prompt)

  const context = {
    style: CONFIG.style,
    mood: CONFIG.mood,
    recentPrompts: recentPromptTexts,
  }

  const results = []

  for (let i = 0; i < count; i++) {
    try {
      logger.info(`Generating prompt ${i + 1}/${count}...`)

      const prompt = await generatePromptWithGemini(character, context)
      const caption = await generateInstagramCaption(prompt, character)

      const savedPrompt = await savePrompt(character.id, prompt, caption)

      results.push({
        success: true,
        prompt,
        caption,
        id: savedPrompt?.id,
      })

      logger.info(`✅ Generated prompt ${i + 1}: ${prompt.substring(0, 50)}...`)

      // Add delay between generations to avoid rate limits
      if (i < count - 1) {
        await new Promise((resolve) => setTimeout(resolve, 2000))
      }
    } catch (error) {
      logger.error(`❌ Failed to generate prompt ${i + 1}: ${error.message}`)
      results.push({
        success: false,
        error: error.message,
      })
    }
  }

  return results
}

async function main() {
  logger.info("Starting prompt generation...")

  if (!CONFIG.geminiApiKey) {
    logger.error("GEMINI_API_KEY environment variable is required")
    process.exit(1)
  }

  try {
    const characters = await loadCharacters()

    if (characters.length === 0) {
      logger.warn("No characters found")
      process.exit(1)
    }

    let charactersToProcess = []

    if (CONFIG.characterId) {
      if (CONFIG.characterId === "all") {
        charactersToProcess = characters.filter((c) => c.isActive)
      } else {
        const character = characters.find((c) => c.id === CONFIG.characterId)
        if (character) {
          charactersToProcess = [character]
        } else {
          logger.error(`Character not found: ${CONFIG.characterId}`)
          process.exit(1)
        }
      }
    } else {
      logger.error('CHARACTER_ID is required (use "all" for all active characters)')
      process.exit(1)
    }

    logger.info(`Processing ${charactersToProcess.length} character(s)`)

    const allResults = []

    for (const character of charactersToProcess) {
      try {
        const results = await generatePromptsForCharacter(character, CONFIG.count)
        allResults.push({
          characterId: character.id,
          characterName: character.name,
          results,
        })

        const successful = results.filter((r) => r.success).length
        const failed = results.filter((r) => !r.success).length

        logger.info(`${character.name}: ${successful} successful, ${failed} failed`)
      } catch (error) {
        logger.error(`Failed to process ${character.name}: ${error.message}`)
        allResults.push({
          characterId: character.id,
          characterName: character.name,
          error: error.message,
        })
      }
    }

    // Summary
    const totalSuccessful = allResults.reduce(
      (sum, char) => sum + (char.results?.filter((r) => r.success).length || 0),
      0,
    )
    const totalFailed = allResults.reduce((sum, char) => sum + (char.results?.filter((r) => !r.success).length || 0), 0)

    logger.info(`\n📊 Summary:`)
    logger.info(`✅ Total prompts generated: ${totalSuccessful}`)
    logger.info(`❌ Total failures: ${totalFailed}`)

    // Output results as JSON for programmatic use
    if (process.env.OUTPUT_JSON === "true") {
      console.log(JSON.stringify(allResults, null, 2))
    }

    process.exit(totalFailed > 0 ? 1 : 0)
  } catch (error) {
    logger.error(`Fatal error: ${error.message}`)
    process.exit(1)
  }
}

// Handle process signals
process.on("SIGINT", () => {
  logger.info("Received SIGINT, shutting down gracefully...")
  process.exit(0)
})

process.on("SIGTERM", () => {
  logger.info("Received SIGTERM, shutting down gracefully...")
  process.exit(0)
})

// Run the main function
if (require.main === module) {
  main()
}

module.exports = {
  generatePromptsForCharacter,
  generatePromptWithGemini,
  loadCharacters,
}
